package golite

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

// TestDeployUnobservedFilesNotProcessedByAssetmin replicates the exact bug scenario:
// When golite starts with deploy section, the _worker.js file generated by goflare
// should NOT be processed by assetmin handler. This test verifies that _worker.js
// content does NOT appear in src/web/public/main.js
//
// Bug description from docs/issues/BUG_UNOBSERVEDFILES.md:
// - deploy/edgeworker/_worker.js is generated by goflare
// - This file should be in UnobservedFiles list
// - But it's being detected and processed by assetmin
// - Its content incorrectly appears in src/web/public/main.js
func TestDeployUnobservedFilesNotProcessedByAssetmin(t *testing.T) {
	tmp := t.TempDir()

	// Create exact project structure from golite/example
	directories := []string{
		"src/cmd/appserver",
		"src/cmd/webclient",
		"src/cmd/edgeworker",
		"src/web/public",
		"src/web/ui/js",
		"deploy/edgeworker",
		"deploy/appserver",
	}

	for _, dir := range directories {
		require.NoError(t, os.MkdirAll(filepath.Join(tmp, dir), 0755))
	}

	// Create a simple edgeworker main.go
	edgeWorkerMain := `package main

func main() {
	println("Edge Worker")
}`
	require.NoError(t, os.WriteFile(
		filepath.Join(tmp, "src/cmd/edgeworker/main.go"),
		[]byte(edgeWorkerMain),
		0644,
	))

	// Create a simple JS file in web/ui that should be processed
	themeJS := `console.log("Theme JS - should be in main.js");`
	require.NoError(t, os.WriteFile(
		filepath.Join(tmp, "src/web/ui/theme.js"),
		[]byte(themeJS),
		0644,
	))

	// Create go.mod
	goMod := `module testproject

go 1.21
`
	require.NoError(t, os.WriteFile(filepath.Join(tmp, "go.mod"), []byte(goMod), 0644))

	// Capture logs to verify what files are being processed
	var logs bytes.Buffer
	logger := func(messages ...any) {
		var msg string
		for i, m := range messages {
			if i > 0 {
				msg += " "
			}
			msg += fmt.Sprint(m)
		}
		logs.WriteString(msg + "\n")
		t.Log(msg) // Also log to test output for debugging
	}

	// Start golite with deploy section
	exitChan := make(chan bool)
	go Start(tmp, logger, newUiMockTest(logger), exitChan)

	// Wait for initialization
	time.Sleep(100 * time.Millisecond)

	// Verify goflare handler exists and has correct UnobservedFiles
	require.NotNil(t, ActiveHandler, "ActiveHandler should be set")
	require.NotNil(t, ActiveHandler.deployCloudflare, "deployCloudflare should be initialized")

	unobservedFiles := ActiveHandler.deployCloudflare.UnobservedFiles()
	t.Logf("Goflare UnobservedFiles: %v", unobservedFiles)

	// Verify UnobservedFiles contains the expected files (both should be RELATIVE paths)
	expectedFiles := []string{
		"deploy/edgeworker/app.wasm",
		"deploy/edgeworker/_worker.js",
	}

	for _, expectedFile := range expectedFiles {
		found := false
		for _, actual := range unobservedFiles {
			// Normalize paths for comparison (handle / vs \)
			normalizedActual := filepath.ToSlash(actual)
			normalizedExpected := filepath.ToSlash(expectedFile)
			if normalizedActual == normalizedExpected {
				found = true
				break
			}
		}
		require.True(t, found, "UnobservedFiles should contain: %s", expectedFile)
	}

	// Verify paths are relative (not absolute)
	for _, path := range unobservedFiles {
		require.False(t, filepath.IsAbs(path),
			"UnobservedFiles should contain relative paths, got: %s", path)
	}

	// Now manually trigger goflare to generate _worker.js
	// (In real scenario this happens via TUI shortcut)
	workerJsPath := filepath.Join(tmp, "deploy/edgeworker/_worker.js")
	workerContent := `// This is _worker.js content from goflare
export default {
	async fetch(request, env, ctx) {
		return new Response("Edge Worker Response");
	}
};`
	require.NoError(t, os.WriteFile(workerJsPath, []byte(workerContent), 0644))

	t.Logf("Created _worker.js at: %s", workerJsPath)

	// Give time for file watcher to potentially detect the file
	time.Sleep(500 * time.Millisecond)

	// Check main.js path
	mainJsPath := filepath.Join(tmp, "src/web/public/main.js")

	// Trigger a JS file modification to ensure main.js is written
	themeJsPath := filepath.Join(tmp, "src/web/ui/theme.js")
	require.NoError(t, os.WriteFile(themeJsPath, []byte(themeJS+"// modified"), 0644))

	// Wait for processing
	time.Sleep(300 * time.Millisecond)

	// Read main.js if it exists
	var mainJsContent []byte
	if _, err := os.Stat(mainJsPath); err == nil {
		mainJsContent, err = os.ReadFile(mainJsPath)
		require.NoError(t, err)
		t.Logf("main.js content length: %d bytes", len(mainJsContent))
	} else {
		t.Logf("main.js not created yet")
	}

	// Parse logs to check if ASSETS handler processed _worker.js
	logsStr := logs.String()
	assetLines := []string{}
	for _, line := range strings.Split(logsStr, "\n") {
		if strings.Contains(line, "ASSETS") && strings.Contains(line, ".js") {
			assetLines = append(assetLines, line)
		}
	}

	t.Logf("\n=== ASSETS .js logs ===")
	for _, line := range assetLines {
		t.Logf("%s", line)
	}

	// THE CRITICAL ASSERTION: _worker.js should NOT be processed by ASSETS
	workerProcessedByAssets := false
	for _, line := range assetLines {
		if strings.Contains(line, "_worker.js") {
			workerProcessedByAssets = true
			t.Errorf("BUG DETECTED: ASSETS handler processed _worker.js: %s", line)
		}
	}

	if !workerProcessedByAssets {
		t.Logf("✓ PASS: _worker.js was NOT processed by ASSETS handler")
	}

	// Verify _worker.js content is NOT in main.js
	if len(mainJsContent) > 0 {
		// Check for distinctive content from _worker.js
		workerSignatures := []string{
			"Edge Worker Response",
			"async fetch(request, env, ctx)",
			"export default",
		}

		for _, signature := range workerSignatures {
			if bytes.Contains(mainJsContent, []byte(signature)) {
				t.Errorf("BUG DETECTED: main.js contains _worker.js signature: '%s'", signature)
			}
		}

		// Verify theme.js content IS in main.js (as expected)
		if !bytes.Contains(mainJsContent, []byte("Theme JS - should be in main.js")) {
			t.Logf("Note: main.js doesn't contain theme.js content (may not have been processed yet)")
		} else {
			t.Logf("✓ PASS: main.js contains theme.js content (as expected)")
		}
	}

	// Additional verification: Check watcher's unobserved files
	if ActiveHandler.watcher != nil {
		t.Logf("\n=== Devwatch Configuration ===")

		// Check if _worker.js is in the watcher's no_add_to_watch map
		// We can't access private field directly, but we can check via logs

		// List all files in deploy directory to verify they exist
		deployFiles := []string{}
		filepath.Walk(filepath.Join(tmp, "deploy"), func(path string, info os.FileInfo, err error) error {
			if err == nil && !info.IsDir() {
				rel, _ := filepath.Rel(tmp, path)
				deployFiles = append(deployFiles, rel)
			}
			return nil
		})
		t.Logf("Files in deploy directory: %v", deployFiles)
	}

	// Stop the application
	exitChan <- true
	time.Sleep(100 * time.Millisecond)

	// Final summary
	t.Logf("\n=== TEST SUMMARY ===")
	t.Logf("UnobservedFiles from goflare: %v", unobservedFiles)
	t.Logf("_worker.js processed by ASSETS: %v (should be false)", workerProcessedByAssets)
	t.Logf("main.js size: %d bytes", len(mainJsContent))

	if workerProcessedByAssets {
		t.Fatalf("TEST FAILED: _worker.js was incorrectly processed by ASSETS handler")
	}
}
